import argparse
import csv
from datetime import datetime
from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent
OUTPUT_DIR = ROOT / "output"
DEFAULT_INPUT = OUTPUT_DIR / "asset_scores.csv"
DEFAULT_OUTPUT = OUTPUT_DIR / "Assets.current.md"


def read_rows(path: Path):
    with path.open(newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        return list(reader)


def bucket_groups(rows):
    groups = {
        "Immediate": [],
        "Near-Term": [],
        "Background": [],
        "Archive": [],
        "Reject": [],
    }
    for r in rows:
        bucket = r.get("Bucket", "").strip()
        if bucket not in groups:
            # Map any unknowns to Background
            bucket = "Background"
        groups[bucket].append(r)
    # sort by Score desc where present
    for k in groups:

        def score_key(x):
            try:
                return float(x.get("Score", 0.0))
            except Exception:
                return 0.0

        groups[k].sort(key=score_key, reverse=True)
    return groups


def esscape(s):
    return (s or "").replace("|", "\\|")


def render_table(headers, rows):
    def esc(s: str) -> str:
        s = s or ""
        return s.replace("|", "\\|")

    out = []
    out.append("| " + " | ".join(headers) + " |")
    out.append("|" + "-".join(["-" * (len(h) + 2) for h in headers]) + "|")
    for r in rows:
        out.append("| " + " | ".join(esc(str(r.get(h, ""))) for h in headers) + " |")
    return "\n".join(out)


def build_index_md(groups):
    now = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
    parts = []
    parts.append("# Current Asset Liquidity Map\n")
    parts.append(f"_Last updated: {now}_\n_Source: output/asset_scores.csv_\n\n---\n")

    # Immediate
    parts.append("## Immediate – Execute Now\n\n")
    headers = [
        "Rank",
        "Asset",
        "Score",
        "TTC",
        "LTV",
        "LD",
        "CC",
        "VF",
        "Owner",
        "Notes",
    ]
    rows = []
    for i, r in enumerate(groups.get("Immediate", []), start=1):
        rows.append(
            {
                "Rank": i,
                "Asset": r.get("Asset", ""),
                "Score": r.get("Score", ""),
                "TTC": r.get("TTC", ""),
                "LTV": r.get("LTV", ""),
                "LD": r.get("LD", ""),
                "CC": r.get("CC", ""),
                "VF": r.get("VF", ""),
                "Owner": r.get("Owner", ""),
                "Notes": r.get("Notes", ""),
            }
        )
    parts.append(render_table(headers, rows) + "\n\n---\n\n")

    # Near-Term
    parts.append("## Near-Term – Unlock to Promote\n\n")
    headers = [
        "Rank",
        "Asset",
        "Score",
        "Key Unlock",
        "TTC After Unlock",
        "Owner",
        "Notes",
    ]
    rows = []
    for i, r in enumerate(groups.get("Near-Term", []), start=1):
        rows.append(
            {
                "Rank": i,
                "Asset": r.get("Asset", ""),
                "Score": r.get("Score", ""),
                "Key Unlock": r.get("KeyUnlock", r.get("Unlock", "")),
                "TTC After Unlock": r.get("TTC_After", ""),
                "Owner": r.get("Owner", ""),
                "Notes": r.get("Notes", ""),
            }
        )
    parts.append(render_table(headers, rows) + "\n\n---\n\n")

    # Background
    parts.append("## Background – Slow Build\n\n")
    headers = ["Asset", "Score", "Main Workstream", "Owner", "Reason It's Background"]
    rows = []
    for r in groups.get("Background", []):
        rows.append(
            {
                "Asset": r.get("Asset", ""),
                "Score": r.get("Score", ""),
                "Main Workstream": r.get("Workstream", ""),
                "Owner": r.get("Owner", ""),
                "Reason It's Background": r.get("Reason", ""),
            }
        )
    parts.append(render_table(headers, rows) + "\n\n---\n\n")

    # Archive
    parts.append("## Archive – Parked but Real\n\n")
    headers = ["Asset", "Score", "Reason Archived", "Revisit Trigger"]
    rows = []
    for r in groups.get("Archive", []):
        rows.append(
            {
                "Asset": r.get("Asset", ""),
                "Score": r.get("Score", ""),
                "Reason Archived": r.get("Reason", ""),
                "Revisit Trigger": r.get("Revisit", ""),
            }
        )
    parts.append(render_table(headers, rows) + "\n\n---\n\n")

    parts.append("## Reject / Dogshit – Logged Separately\n\n")
    parts.append(
        "See: `docs/templates/scoring/RejectLog.template.md` and the Reject section in `output/asset_scores.md` for rule triggers and reasons.\n\n"
    )
    parts.append(
        f"_Generated by the FTH Liquidity Engine on: {now}.  This is a planning tool, not an offering document. All transactions remain subject to legal, compliance, and counterparty approvals._\n"
    )

    return "".join(parts)


def parse_args():
    p = argparse.ArgumentParser(
        description="Generate grouped Assets.current.md from asset_scores.csv"
    )
    p.add_argument(
        "--input",
        "-i",
        type=str,
        default=str(DEFAULT_INPUT),
        help="Path to asset_scores.csv",
    )
    p.add_argument(
        "--output",
        "-o",
        type=str,
        default=str(DEFAULT_OUTPUT),
        help="Path to write Assets.current.md",
    )
    return p.parse_args()


def main():
    args = parse_args()
    input_path = Path(args.input)
    output_path = Path(args.output)
    if not input_path.exists():
        raise SystemExit(f"Missing CSV: {input_path}")
    rows = read_rows(input_path)
    groups = bucket_groups(rows)
    output_path.write_text(build_index_md(groups), encoding="utf-8")
    print(f"Wrote {output_path}")


if __name__ == "__main__":
    main()
